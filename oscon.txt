* Test and Behavior Driven Development in JavaScript
* Intro/Context
** JavaScript means different things to different people
** ChessFlock
*** demo
*** tests
*** motivation
**** html5 app
**** svg
**** localstorage
**** offline/cache-manifest
**** distributed
***** xmpp-based ipc
*** caveats
**** incomplete
**** low test coverage
**** rationalization
***** throw one away
***** test bed for dramatis, etc.
**** some egregiously bad stuff in there

* TDD
** writing the tests first

* Kinds of tests
** Unit        
** Integration
*** Approaches
**** Unintegrated
***** Selenium/Watir
**** Integrated
***** webrat/capybara
***** Most appropriate for testing webapps

* JavaScript
** The language
** The libraries/environments

* JavaScript vs X
** Dynamically typed
*** not writing tests is grounds for involunatry commitment
** Asynchronous
** Event-driven
*** document.write vs ajax

* Testing frameworks
**  qunit
*** Test-unit like
*** Very simple
*** Resig
**** jQuery, env-js
*** Example
*** Beyond the simple: async
**** expect
**** stop
**** start
** Jasmine
*** RSpec
*** Screw-Unit
*** BDD
**** unlimited nesting
**** "this"-per test
** Others
**** Fairly fractured

Looked at many of them
Justice to none

**  Common-ish
***    Asynch    
** JSLint: in a class of its own
** Runners

* Developing JavaScript
** Dom-related
** Not DOM related
** TDD
*** RGR

* Ready, Set, Go ...
** Uh ...
** Where, When, How, Why
*** Fixtures
*** Or ...

* Interpreters
** JavaScript w/o the DOM is a very limited, speicaled library

* JavaScript++
**  Browsers
***    Firebug/Developer tools
**  Browser environments
***    HTMLUnit (Rhino)
***    Env.js (Rhino and SpiderMonkey)
**  CommonJS environments
***    Node.js
***    I know next to nothing about this

* Browser++
**  HTML5 +/-
**  DOM
***    document
***    window
**  XHR
***  Timers/event loop
**  I/O
***    console.*

* Runners
**  Load a page/hit refresh
**  Blueridge (RIP)
**  Jasmine ruby gem

* Fixtures
**  I hate fixtures
**  Generic
**  test-specific
**  in-vivo
**  static/dynamic

*RGR
**  Refresh
**  make/ant/rake
**  incremental/realtime
***    autotest
***    wake
****    dependences

* Me Me Me
**  TTT
**  ChessFlock
**  Dramatis
**  Screw-Unit => Jasmine
**  Bluerige => jazz/wake
**  Jasmine fork
***    incomplete/complete
***    eventually
***    wait_for
**  Jazz
***    Jasmine runner
***    automatic fixture (in-vivo and in-situ) detection and pairing
***    wake integration
  wake
**    make/rake + autotest/watchr
***    graph dependeces/leveling
***    API    
***    plugins
****      haml/sass
****      jslint
****      jazz
****      cache_manifest
****      graphics
***  jsrat
****    fill_in
****    click_link

JSTestDriver

TestSwarm

In JavaScript, you write your code, create an HTML fixture page to
test that code, load that page in browser, click a few times, and look
to see if the result looks right. Then you switch back to your editor,
modify your code, bring the browser up again, hit browser refresh, click, look ...

Or, more likely, you don't. At least not very often.

And if you do run tests, you only run the tests you think you broke,
rather than the ones you actually did break.

Much of this is because in JavaScript it has been harder to _run_
tests than it has been to _write_ them.

It's now possible to do much better than
edit/refresh/look/repeat. Borrowing heavily from best practices in
other languages, it's now possible to make JavaScript unit testing as
easy as in, say, Ruby:

* Without ever leaving your editor/IDE
* Running tests without a browser
* Running all tests in the browser quickly

In this talk we'll walk through the process of developing/modifying a
JavaScript browser-based application in a test-first manner, showing
how every step can be automated for immediate feedback to the
developer.

Highlights:

* Running tests without an HTML fixture
* Running tests against production HTML in situ
* Test driven development with qunit
* Behavior-driven development with jasmine
* Using SpiderMonkey and Johnson to run JavaScript out of the browser _fast_
* Using env.js to test within the browser environment without a browser
* Using jazrb to run jasmine and qunit tests from the command line and get RSpec or JUnit output
* Using wake to run all affected tests (and jslint!) on every save
* Testing asynchronous JavaScript

1 Writing asynchronous tests

packaging/building/serving

you *can* test all your JavaScript with refresh
do you want to?

in browser/out of browser

designer vs. javascript developer

xunit

code is pretty much available now

fixture

demo soup to nuts

As the lingua franca of the web, JavaScript is the 

Reliable
Agile

JavaScript is the lingua franca of the web
JavaScript is the lingua franca of the mobile web

SpiderMonkey
env.js
jslint

build

javascript testing without the browser

selenium

unit testing vs. functional testing vs. integration testing

javascript
  javascript vs. the browser
  browser event model
  asynchronous

asynchronous!

testing frameworks
  qunit
  jasmine
  ScrewUnit

real-time TDD

intermediate
p
single page/multiple page

jazrb
  eventmachine
wake
jslintrb

CI
