ChessFlock

TDD
  writing the tests first

Kinds of tests
  Unit        
  Integration
    Approaches
      Unintegrated
        Selenium/Watir
      Integrated
        webrat/capybara
    Most appropriate for testing webapps

JavaScript
  The language
  The libraries/environments

JavaScript vs X for any X
  Asynchronous
  Event-driven
    document.write vs ajax

Testing frameworks
  qunit
    Test-unit like
      Very simple
      Resig
      jQuery
    Async!
      expect
      stop
      start
  Jasmine
    RSpec
    Screw-Unit
    BDD
      unlimited nesting
      "this"-per test
  Others
    Fairly fractured
    Looked at many of them
    Justice to none
  Common-ish
    Asynch    
  JSLint

Developing JavaScript
  Dom-related
  Not DOM related
  TDD
    RGR

Ready, Set, Go ...
  Where, When, How, Why
  Uh ...
  Fixtures
  Or ...

Interpreters
  JavaScript w/o the DOM is a very limited, speicaled library

JavaScript++
  Browsers
    Firebug/Developer tools
  Browser environments
    HTMLUnit (Rhino)
    Env.js (Rhino and SpiderMonkey)
  CommonJS environments
    Node.js
    I know next to nothing about this

Browser++
  HTML5 +/-
  DOM
    document
    window
  XHR
  Timers/event loop
  I/O
    console.*

Runners
  Load a page/hit refresh
  Blueridge (RIP)
  Jasmine ruby gem

Fixtures
  I hate fixtures
  Generic
  test-specific
  in-vivo
  static/dynamic

RGR
  Refresh
  make/ant/rake
  incremental/realtime
    autotest
    wake
    dependences

Me Me Me
  TTT
  ChessFlock
  Dramatis
  Screw-Unit => Jasmine
  Bluerige => jazz/wake
  Jasmine fork
    incomplete/complete
    eventually
    wait_for
  Jazz
    Jasmine runner
    automatic fixture (in-vivo and in-situ) detection and pairing
    wake integration
  wake
    make/rake + autotest/watchr
    graph dependeces/leveling
    API    
    plugins
      haml/sass
      jslint
      jazz
      cache_manifest
      graphics
        batik
  jsrat
    fill_in
    click_link

JSTestDriver

TestSwarm

JavaScript has a number of unit test frameworks as well, but they see far
less use than those seen in other languages. What JavaScript doesn't
have is an environment that makes it easy for a developer to write and
run their tests without breaking their train of thought.

In Java you run Eclipse or ant. In Ruby you run rake or autotest. In
python you run python or nose.

In JavaScript, you write your code, create an HTML fixture page to
test that code, load that page in browser, click a few times, and look
to see if the result looks right. Then you switch back to your editor,
modify your code, bring the browser up again, hit browser refresh, click, look ...

Or, more likely, you don't. At least not very often.

And if you do run tests, you only run the tests you think you broke,
rather than the ones you actually did break.

Much of this is because in JavaScript it has been harder to _run_
tests than it has been to _write_ them.

It's now possible to do much better than
edit/refresh/look/repeat. Borrowing heavily from best practices in
other languages, it's now possible to make JavaScript unit testing as
easy as in, say, Ruby:

* Without ever leaving your editor/IDE
* Running tests without a browser
* Running all tests in the browser quickly

In this talk we'll walk through the process of developing/modifying a
JavaScript browser-based application in a test-first manner, showing
how every step can be automated for immediate feedback to the
developer.

Highlights:

* Running tests without an HTML fixture
* Running tests against production HTML in situ
* Test driven development with qunit
* Behavior-driven development with jasmine
* Using SpiderMonkey and Johnson to run JavaScript out of the browser _fast_
* Using env.js to test within the browser environment without a browser
* Using jazrb to run jasmine and qunit tests from the command line and get RSpec or JUnit output
* Using wake to run all affected tests (and jslint!) on every save
* Testing asynchronous JavaScript

1 Writing asynchronous tests

packaging/building/serving

you *can* test all your JavaScript with refresh
do you want to?

in browser/out of browser

designer vs. javascript developer

xunit

code is pretty much available now

fixture

demo soup to nuts

As the lingua franca of the web, JavaScript is the 

Reliable
Agile

JavaScript is the lingua franca of the web
JavaScript is the lingua franca of the mobile web

SpiderMonkey
env.js
jslint

build

javascript testing without the browser

selenium

unit testing vs. functional testing vs. integration testing

javascript
  javascript vs. the browser
  browser event model
  asynchronous

asynchronous!

testing frameworks
  qunit
  jasmine
  ScrewUnit

real-time TDD

intermediate
p
single page/multiple page

jazrb
  eventmachine
wake
jslintrb

CI
